限流，熔断，降级的常用方式：
    限流：
        1.令牌桶算法：是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌
            -- 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌
            -- 桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝
            -- 当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上
            - 如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）
        2.漏桶算法：作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing）
            -- 一个固定容量的漏桶，按照常量固定速率流出水滴
            -- 如果桶是空的，则不需流出水滴
            -- 可以以任意速率流入水滴到漏桶
            -- 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的
        3.QPS 限流
            -- 不同的请求可能需要数量迥异的资源来处理
            -- 某种静态 QPS 限流不是特别准
        4.分布式限流

    熔断
        Google SRE: max(0, (requests - K*accepts) / (requests + 1))
        Gutter：基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题

    降级
        1.页面降级、延迟服务、写/读降级、缓存降级
        2.抛异常、返回约定协议、Mock 数据、Fallback 处理

重试的注意事项
    1.限制重试次数和基于重试分布的策略（重试比率: 10%）
    2.随机化、指数型递增的重试周期: exponential ackoff + jitter
    3.client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝
    4.只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试

负载均衡的常用方式
    我们使用 p2c 算法，随机选取的两个节点进行打分，选择更优的节点：
        1.选择 backend：CPU，client：health、inflight、latency 作为指标，使用一个简单的线性方程进行打分
        2.对新启动的节点使用常量惩罚值（penalty），以及使用探针方式最小化放量，进行预热
        3.打分比较低的节点，避免进入“永久黑名单”而无法恢复，使用统计衰减的方式，让节点指标逐渐恢复到初始状态(即默认值)
        4.当前发出去的请求超过了 predict lagtency，就会加惩罚
        ***指标计算结合 moving average，使用时间衰减，计算vt = v(t-1) * β + at * (1-β) ，β 为若干次幂的倒数即: Math.Exp((-span) / 600ms)
